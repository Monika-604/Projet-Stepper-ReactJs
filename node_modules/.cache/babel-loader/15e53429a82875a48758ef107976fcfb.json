{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validation = void 0;\n\nconst argsert_1 = require(\"./argsert\");\n\nconst common_types_1 = require(\"./common-types\");\n\nconst levenshtein_1 = require(\"./levenshtein\");\n\nconst obj_filter_1 = require(\"./obj-filter\");\n\nconst specialKeys = ['$0', '--', '_']; // validation-type-stuff, missing params,\n// bad implications, custom checks.\n\nfunction validation(yargs, usage, y18n) {\n  const __ = y18n.__;\n  const __n = y18n.__n;\n  const self = {}; // validate appropriate # of non-option\n  // arguments were provided, i.e., '_'.\n\n  self.nonOptionCount = function nonOptionCount(argv) {\n    const demandedCommands = yargs.getDemandedCommands(); // don't count currently executing commands\n\n    const _s = argv._.length - yargs.getContext().commands.length;\n\n    if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {\n      if (_s < demandedCommands._.min) {\n        if (demandedCommands._.minMsg !== undefined) {\n          usage.fail( // replace $0 with observed, $1 with expected.\n          demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\\$0/g, _s.toString()).replace(/\\$1/, demandedCommands._.min.toString()) : null);\n        } else {\n          usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', _s, _s, demandedCommands._.min));\n        }\n      } else if (_s > demandedCommands._.max) {\n        if (demandedCommands._.maxMsg !== undefined) {\n          usage.fail( // replace $0 with observed, $1 with expected.\n          demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\\$0/g, _s.toString()).replace(/\\$1/, demandedCommands._.max.toString()) : null);\n        } else {\n          usage.fail(__n('Too many non-option arguments: got %s, maximum of %s', 'Too many non-option arguments: got %s, maximum of %s', _s, _s, demandedCommands._.max));\n        }\n      }\n    }\n  }; // validate the appropriate # of <required>\n  // positional arguments were provided:\n\n\n  self.positionalCount = function positionalCount(required, observed) {\n    if (observed < required) {\n      usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', observed, observed, required));\n    }\n  }; // make sure all the required arguments are present.\n\n\n  self.requiredArguments = function requiredArguments(argv) {\n    const demandedOptions = yargs.getDemandedOptions();\n    let missing = null;\n\n    for (const key of Object.keys(demandedOptions)) {\n      if (!Object.prototype.hasOwnProperty.call(argv, key) || typeof argv[key] === 'undefined') {\n        missing = missing || {};\n        missing[key] = demandedOptions[key];\n      }\n    }\n\n    if (missing) {\n      const customMsgs = [];\n\n      for (const key of Object.keys(missing)) {\n        const msg = missing[key];\n\n        if (msg && customMsgs.indexOf(msg) < 0) {\n          customMsgs.push(msg);\n        }\n      }\n\n      const customMsg = customMsgs.length ? `\\n${customMsgs.join('\\n')}` : '';\n      usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));\n    }\n  }; // check for unknown arguments (strict-mode).\n\n\n  self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand) {\n    const commandKeys = yargs.getCommandInstance().getCommands();\n    const unknown = [];\n    const currentContext = yargs.getContext();\n    Object.keys(argv).forEach(key => {\n      if (specialKeys.indexOf(key) === -1 && !Object.prototype.hasOwnProperty.call(positionalMap, key) && !Object.prototype.hasOwnProperty.call(yargs._getParseContext(), key) && !self.isValidAndSomeAliasIsNotNew(key, aliases)) {\n        unknown.push(key);\n      }\n    });\n\n    if (currentContext.commands.length > 0 || commandKeys.length > 0 || isDefaultCommand) {\n      argv._.slice(currentContext.commands.length).forEach(key => {\n        if (commandKeys.indexOf(key) === -1) {\n          unknown.push(key);\n        }\n      });\n    }\n\n    if (unknown.length > 0) {\n      usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.join(', ')));\n    }\n  };\n\n  self.unknownCommands = function unknownCommands(argv) {\n    const commandKeys = yargs.getCommandInstance().getCommands();\n    const unknown = [];\n    const currentContext = yargs.getContext();\n\n    if (currentContext.commands.length > 0 || commandKeys.length > 0) {\n      argv._.slice(currentContext.commands.length).forEach(key => {\n        if (commandKeys.indexOf(key) === -1) {\n          unknown.push(key);\n        }\n      });\n    }\n\n    if (unknown.length > 0) {\n      usage.fail(__n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', ')));\n      return true;\n    } else {\n      return false;\n    }\n  }; // check for a key that is not an alias, or for which every alias is new,\n  // implying that it was invented by the parser, e.g., during camelization\n\n\n  self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {\n    if (!Object.prototype.hasOwnProperty.call(aliases, key)) {\n      return false;\n    }\n\n    const newAliases = yargs.parsed.newAliases;\n\n    for (const a of [key, ...aliases[key]]) {\n      if (!Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]) {\n        return true;\n      }\n    }\n\n    return false;\n  }; // validate arguments limited to enumerated choices\n\n\n  self.limitedChoices = function limitedChoices(argv) {\n    const options = yargs.getOptions();\n    const invalid = {};\n    if (!Object.keys(options.choices).length) return;\n    Object.keys(argv).forEach(key => {\n      if (specialKeys.indexOf(key) === -1 && Object.prototype.hasOwnProperty.call(options.choices, key)) {\n        [].concat(argv[key]).forEach(value => {\n          // TODO case-insensitive configurability\n          if (options.choices[key].indexOf(value) === -1 && value !== undefined) {\n            invalid[key] = (invalid[key] || []).concat(value);\n          }\n        });\n      }\n    });\n    const invalidKeys = Object.keys(invalid);\n    if (!invalidKeys.length) return;\n\n    let msg = __('Invalid values:');\n\n    invalidKeys.forEach(key => {\n      msg += `\\n  ${__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;\n    });\n    usage.fail(msg);\n  }; // custom checks, added using the `check` option on yargs.\n\n\n  let checks = [];\n\n  self.check = function check(f, global) {\n    checks.push({\n      func: f,\n      global\n    });\n  };\n\n  self.customChecks = function customChecks(argv, aliases) {\n    for (let i = 0, f; (f = checks[i]) !== undefined; i++) {\n      const func = f.func;\n      let result = null;\n\n      try {\n        result = func(argv, aliases);\n      } catch (err) {\n        usage.fail(err.message ? err.message : err, err);\n        continue;\n      }\n\n      if (!result) {\n        usage.fail(__('Argument check failed: %s', func.toString()));\n      } else if (typeof result === 'string' || result instanceof Error) {\n        usage.fail(result.toString(), result);\n      }\n    }\n  }; // check implications, argument foo implies => argument bar.\n\n\n  let implied = {};\n\n  self.implies = function implies(key, value) {\n    argsert_1.argsert('<string|object> [array|number|string]', [key, value], arguments.length);\n\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(k => {\n        self.implies(k, key[k]);\n      });\n    } else {\n      yargs.global(key);\n\n      if (!implied[key]) {\n        implied[key] = [];\n      }\n\n      if (Array.isArray(value)) {\n        value.forEach(i => self.implies(key, i));\n      } else {\n        common_types_1.assertNotStrictEqual(value, undefined);\n        implied[key].push(value);\n      }\n    }\n  };\n\n  self.getImplied = function getImplied() {\n    return implied;\n  };\n\n  function keyExists(argv, val) {\n    // convert string '1' to number 1\n    const num = Number(val);\n    val = isNaN(num) ? val : num;\n\n    if (typeof val === 'number') {\n      // check length of argv._\n      val = argv._.length >= val;\n    } else if (val.match(/^--no-.+/)) {\n      // check if key/value doesn't exist\n      val = val.match(/^--no-(.+)/)[1];\n      val = !argv[val];\n    } else {\n      // check if key/value exists\n      val = argv[val];\n    }\n\n    return val;\n  }\n\n  self.implications = function implications(argv) {\n    const implyFail = [];\n    Object.keys(implied).forEach(key => {\n      const origKey = key;\n      (implied[key] || []).forEach(value => {\n        let key = origKey;\n        const origValue = value;\n        key = keyExists(argv, key);\n        value = keyExists(argv, value);\n\n        if (key && !value) {\n          implyFail.push(` ${origKey} -> ${origValue}`);\n        }\n      });\n    });\n\n    if (implyFail.length) {\n      let msg = `${__('Implications failed:')}\\n`;\n      implyFail.forEach(value => {\n        msg += value;\n      });\n      usage.fail(msg);\n    }\n  };\n\n  let conflicting = {};\n\n  self.conflicts = function conflicts(key, value) {\n    argsert_1.argsert('<string|object> [array|string]', [key, value], arguments.length);\n\n    if (typeof key === 'object') {\n      Object.keys(key).forEach(k => {\n        self.conflicts(k, key[k]);\n      });\n    } else {\n      yargs.global(key);\n\n      if (!conflicting[key]) {\n        conflicting[key] = [];\n      }\n\n      if (Array.isArray(value)) {\n        value.forEach(i => self.conflicts(key, i));\n      } else {\n        conflicting[key].push(value);\n      }\n    }\n  };\n\n  self.getConflicting = () => conflicting;\n\n  self.conflicting = function conflictingFn(argv) {\n    Object.keys(argv).forEach(key => {\n      if (conflicting[key]) {\n        conflicting[key].forEach(value => {\n          // we default keys to 'undefined' that have been configured, we should not\n          // apply conflicting check unless they are a value other than 'undefined'.\n          if (value && argv[key] !== undefined && argv[value] !== undefined) {\n            usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));\n          }\n        });\n      }\n    });\n  };\n\n  self.recommendCommands = function recommendCommands(cmd, potentialCommands) {\n    const threshold = 3; // if it takes more than three edits, let's move on.\n\n    potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);\n    let recommended = null;\n    let bestDistance = Infinity;\n\n    for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {\n      const d = levenshtein_1.levenshtein(cmd, candidate);\n\n      if (d <= threshold && d < bestDistance) {\n        bestDistance = d;\n        recommended = candidate;\n      }\n    }\n\n    if (recommended) usage.fail(__('Did you mean %s?', recommended));\n  };\n\n  self.reset = function reset(localLookup) {\n    implied = obj_filter_1.objFilter(implied, k => !localLookup[k]);\n    conflicting = obj_filter_1.objFilter(conflicting, k => !localLookup[k]);\n    checks = checks.filter(c => c.global);\n    return self;\n  };\n\n  const frozens = [];\n\n  self.freeze = function freeze() {\n    frozens.push({\n      implied,\n      checks,\n      conflicting\n    });\n  };\n\n  self.unfreeze = function unfreeze() {\n    const frozen = frozens.pop();\n    common_types_1.assertNotStrictEqual(frozen, undefined);\n    ({\n      implied,\n      checks,\n      conflicting\n    } = frozen);\n  };\n\n  return self;\n}\n\nexports.validation = validation;","map":{"version":3,"sources":["/Users/monika/Desktop/test/node_modules/yargs/build/lib/validation.js"],"names":["Object","defineProperty","exports","value","validation","argsert_1","require","common_types_1","levenshtein_1","obj_filter_1","specialKeys","yargs","usage","y18n","__","__n","self","nonOptionCount","argv","demandedCommands","getDemandedCommands","_s","_","length","getContext","commands","min","max","minMsg","undefined","fail","replace","toString","maxMsg","positionalCount","required","observed","requiredArguments","demandedOptions","getDemandedOptions","missing","key","keys","prototype","hasOwnProperty","call","customMsgs","msg","indexOf","push","customMsg","join","unknownArguments","aliases","positionalMap","isDefaultCommand","commandKeys","getCommandInstance","getCommands","unknown","currentContext","forEach","_getParseContext","isValidAndSomeAliasIsNotNew","slice","unknownCommands","newAliases","parsed","a","limitedChoices","options","getOptions","invalid","choices","concat","invalidKeys","stringifiedValues","checks","check","f","global","func","customChecks","i","result","err","message","Error","implied","implies","argsert","arguments","k","Array","isArray","assertNotStrictEqual","getImplied","keyExists","val","num","Number","isNaN","match","implications","implyFail","origKey","origValue","conflicting","conflicts","getConflicting","conflictingFn","recommendCommands","cmd","potentialCommands","threshold","sort","b","recommended","bestDistance","Infinity","candidate","d","levenshtein","reset","localLookup","objFilter","filter","c","frozens","freeze","unfreeze","frozen","pop"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validation = void 0;\nconst argsert_1 = require(\"./argsert\");\nconst common_types_1 = require(\"./common-types\");\nconst levenshtein_1 = require(\"./levenshtein\");\nconst obj_filter_1 = require(\"./obj-filter\");\nconst specialKeys = ['$0', '--', '_'];\n// validation-type-stuff, missing params,\n// bad implications, custom checks.\nfunction validation(yargs, usage, y18n) {\n    const __ = y18n.__;\n    const __n = y18n.__n;\n    const self = {};\n    // validate appropriate # of non-option\n    // arguments were provided, i.e., '_'.\n    self.nonOptionCount = function nonOptionCount(argv) {\n        const demandedCommands = yargs.getDemandedCommands();\n        // don't count currently executing commands\n        const _s = argv._.length - yargs.getContext().commands.length;\n        if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {\n            if (_s < demandedCommands._.min) {\n                if (demandedCommands._.minMsg !== undefined) {\n                    usage.fail(\n                    // replace $0 with observed, $1 with expected.\n                    demandedCommands._.minMsg\n                        ? demandedCommands._.minMsg.replace(/\\$0/g, _s.toString()).replace(/\\$1/, demandedCommands._.min.toString())\n                        : null);\n                }\n                else {\n                    usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', _s, _s, demandedCommands._.min));\n                }\n            }\n            else if (_s > demandedCommands._.max) {\n                if (demandedCommands._.maxMsg !== undefined) {\n                    usage.fail(\n                    // replace $0 with observed, $1 with expected.\n                    demandedCommands._.maxMsg\n                        ? demandedCommands._.maxMsg.replace(/\\$0/g, _s.toString()).replace(/\\$1/, demandedCommands._.max.toString())\n                        : null);\n                }\n                else {\n                    usage.fail(__n('Too many non-option arguments: got %s, maximum of %s', 'Too many non-option arguments: got %s, maximum of %s', _s, _s, demandedCommands._.max));\n                }\n            }\n        }\n    };\n    // validate the appropriate # of <required>\n    // positional arguments were provided:\n    self.positionalCount = function positionalCount(required, observed) {\n        if (observed < required) {\n            usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', observed, observed, required));\n        }\n    };\n    // make sure all the required arguments are present.\n    self.requiredArguments = function requiredArguments(argv) {\n        const demandedOptions = yargs.getDemandedOptions();\n        let missing = null;\n        for (const key of Object.keys(demandedOptions)) {\n            if (!Object.prototype.hasOwnProperty.call(argv, key) || typeof argv[key] === 'undefined') {\n                missing = missing || {};\n                missing[key] = demandedOptions[key];\n            }\n        }\n        if (missing) {\n            const customMsgs = [];\n            for (const key of Object.keys(missing)) {\n                const msg = missing[key];\n                if (msg && customMsgs.indexOf(msg) < 0) {\n                    customMsgs.push(msg);\n                }\n            }\n            const customMsg = customMsgs.length ? `\\n${customMsgs.join('\\n')}` : '';\n            usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));\n        }\n    };\n    // check for unknown arguments (strict-mode).\n    self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand) {\n        const commandKeys = yargs.getCommandInstance().getCommands();\n        const unknown = [];\n        const currentContext = yargs.getContext();\n        Object.keys(argv).forEach((key) => {\n            if (specialKeys.indexOf(key) === -1 &&\n                !Object.prototype.hasOwnProperty.call(positionalMap, key) &&\n                !Object.prototype.hasOwnProperty.call(yargs._getParseContext(), key) &&\n                !self.isValidAndSomeAliasIsNotNew(key, aliases)) {\n                unknown.push(key);\n            }\n        });\n        if ((currentContext.commands.length > 0) || (commandKeys.length > 0) || isDefaultCommand) {\n            argv._.slice(currentContext.commands.length).forEach((key) => {\n                if (commandKeys.indexOf(key) === -1) {\n                    unknown.push(key);\n                }\n            });\n        }\n        if (unknown.length > 0) {\n            usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.join(', ')));\n        }\n    };\n    self.unknownCommands = function unknownCommands(argv) {\n        const commandKeys = yargs.getCommandInstance().getCommands();\n        const unknown = [];\n        const currentContext = yargs.getContext();\n        if ((currentContext.commands.length > 0) || (commandKeys.length > 0)) {\n            argv._.slice(currentContext.commands.length).forEach((key) => {\n                if (commandKeys.indexOf(key) === -1) {\n                    unknown.push(key);\n                }\n            });\n        }\n        if (unknown.length > 0) {\n            usage.fail(__n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', ')));\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    // check for a key that is not an alias, or for which every alias is new,\n    // implying that it was invented by the parser, e.g., during camelization\n    self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {\n        if (!Object.prototype.hasOwnProperty.call(aliases, key)) {\n            return false;\n        }\n        const newAliases = yargs.parsed.newAliases;\n        for (const a of [key, ...aliases[key]]) {\n            if (!Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]) {\n                return true;\n            }\n        }\n        return false;\n    };\n    // validate arguments limited to enumerated choices\n    self.limitedChoices = function limitedChoices(argv) {\n        const options = yargs.getOptions();\n        const invalid = {};\n        if (!Object.keys(options.choices).length)\n            return;\n        Object.keys(argv).forEach((key) => {\n            if (specialKeys.indexOf(key) === -1 &&\n                Object.prototype.hasOwnProperty.call(options.choices, key)) {\n                [].concat(argv[key]).forEach((value) => {\n                    // TODO case-insensitive configurability\n                    if (options.choices[key].indexOf(value) === -1 &&\n                        value !== undefined) {\n                        invalid[key] = (invalid[key] || []).concat(value);\n                    }\n                });\n            }\n        });\n        const invalidKeys = Object.keys(invalid);\n        if (!invalidKeys.length)\n            return;\n        let msg = __('Invalid values:');\n        invalidKeys.forEach((key) => {\n            msg += `\\n  ${__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;\n        });\n        usage.fail(msg);\n    };\n    // custom checks, added using the `check` option on yargs.\n    let checks = [];\n    self.check = function check(f, global) {\n        checks.push({\n            func: f,\n            global\n        });\n    };\n    self.customChecks = function customChecks(argv, aliases) {\n        for (let i = 0, f; (f = checks[i]) !== undefined; i++) {\n            const func = f.func;\n            let result = null;\n            try {\n                result = func(argv, aliases);\n            }\n            catch (err) {\n                usage.fail(err.message ? err.message : err, err);\n                continue;\n            }\n            if (!result) {\n                usage.fail(__('Argument check failed: %s', func.toString()));\n            }\n            else if (typeof result === 'string' || result instanceof Error) {\n                usage.fail(result.toString(), result);\n            }\n        }\n    };\n    // check implications, argument foo implies => argument bar.\n    let implied = {};\n    self.implies = function implies(key, value) {\n        argsert_1.argsert('<string|object> [array|number|string]', [key, value], arguments.length);\n        if (typeof key === 'object') {\n            Object.keys(key).forEach((k) => {\n                self.implies(k, key[k]);\n            });\n        }\n        else {\n            yargs.global(key);\n            if (!implied[key]) {\n                implied[key] = [];\n            }\n            if (Array.isArray(value)) {\n                value.forEach((i) => self.implies(key, i));\n            }\n            else {\n                common_types_1.assertNotStrictEqual(value, undefined);\n                implied[key].push(value);\n            }\n        }\n    };\n    self.getImplied = function getImplied() {\n        return implied;\n    };\n    function keyExists(argv, val) {\n        // convert string '1' to number 1\n        const num = Number(val);\n        val = isNaN(num) ? val : num;\n        if (typeof val === 'number') {\n            // check length of argv._\n            val = argv._.length >= val;\n        }\n        else if (val.match(/^--no-.+/)) {\n            // check if key/value doesn't exist\n            val = val.match(/^--no-(.+)/)[1];\n            val = !argv[val];\n        }\n        else {\n            // check if key/value exists\n            val = argv[val];\n        }\n        return val;\n    }\n    self.implications = function implications(argv) {\n        const implyFail = [];\n        Object.keys(implied).forEach((key) => {\n            const origKey = key;\n            (implied[key] || []).forEach((value) => {\n                let key = origKey;\n                const origValue = value;\n                key = keyExists(argv, key);\n                value = keyExists(argv, value);\n                if (key && !value) {\n                    implyFail.push(` ${origKey} -> ${origValue}`);\n                }\n            });\n        });\n        if (implyFail.length) {\n            let msg = `${__('Implications failed:')}\\n`;\n            implyFail.forEach((value) => {\n                msg += (value);\n            });\n            usage.fail(msg);\n        }\n    };\n    let conflicting = {};\n    self.conflicts = function conflicts(key, value) {\n        argsert_1.argsert('<string|object> [array|string]', [key, value], arguments.length);\n        if (typeof key === 'object') {\n            Object.keys(key).forEach((k) => {\n                self.conflicts(k, key[k]);\n            });\n        }\n        else {\n            yargs.global(key);\n            if (!conflicting[key]) {\n                conflicting[key] = [];\n            }\n            if (Array.isArray(value)) {\n                value.forEach((i) => self.conflicts(key, i));\n            }\n            else {\n                conflicting[key].push(value);\n            }\n        }\n    };\n    self.getConflicting = () => conflicting;\n    self.conflicting = function conflictingFn(argv) {\n        Object.keys(argv).forEach((key) => {\n            if (conflicting[key]) {\n                conflicting[key].forEach((value) => {\n                    // we default keys to 'undefined' that have been configured, we should not\n                    // apply conflicting check unless they are a value other than 'undefined'.\n                    if (value && argv[key] !== undefined && argv[value] !== undefined) {\n                        usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));\n                    }\n                });\n            }\n        });\n    };\n    self.recommendCommands = function recommendCommands(cmd, potentialCommands) {\n        const threshold = 3; // if it takes more than three edits, let's move on.\n        potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);\n        let recommended = null;\n        let bestDistance = Infinity;\n        for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {\n            const d = levenshtein_1.levenshtein(cmd, candidate);\n            if (d <= threshold && d < bestDistance) {\n                bestDistance = d;\n                recommended = candidate;\n            }\n        }\n        if (recommended)\n            usage.fail(__('Did you mean %s?', recommended));\n    };\n    self.reset = function reset(localLookup) {\n        implied = obj_filter_1.objFilter(implied, k => !localLookup[k]);\n        conflicting = obj_filter_1.objFilter(conflicting, k => !localLookup[k]);\n        checks = checks.filter(c => c.global);\n        return self;\n    };\n    const frozens = [];\n    self.freeze = function freeze() {\n        frozens.push({\n            implied,\n            checks,\n            conflicting\n        });\n    };\n    self.unfreeze = function unfreeze() {\n        const frozen = frozens.pop();\n        common_types_1.assertNotStrictEqual(frozen, undefined);\n        ({\n            implied,\n            checks,\n            conflicting\n        } = frozen);\n    };\n    return self;\n}\nexports.validation = validation;\n"]},"metadata":{},"sourceType":"script"}