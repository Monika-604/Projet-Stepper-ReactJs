{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.argsert = void 0;\n\nconst yerror_1 = require(\"./yerror\");\n\nconst parse_command_1 = require(\"./parse-command\");\n\nconst positionName = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth'];\n\nfunction argsert(arg1, arg2, arg3) {\n  function parseArgs() {\n    return typeof arg1 === 'object' ? [{\n      demanded: [],\n      optional: []\n    }, arg1, arg2] : [parse_command_1.parseCommand(`cmd ${arg1}`), arg2, arg3];\n  } // TODO: should this eventually raise an exception.\n\n\n  try {\n    // preface the argument description with \"cmd\", so\n    // that we can run it through yargs' command parser.\n    let position = 0;\n    let [parsed, callerArguments, length] = parseArgs();\n    const args = [].slice.call(callerArguments);\n\n    while (args.length && args[args.length - 1] === undefined) args.pop();\n\n    length = length || args.length;\n\n    if (length < parsed.demanded.length) {\n      throw new yerror_1.YError(`Not enough arguments provided. Expected ${parsed.demanded.length} but received ${args.length}.`);\n    }\n\n    const totalCommands = parsed.demanded.length + parsed.optional.length;\n\n    if (length > totalCommands) {\n      throw new yerror_1.YError(`Too many arguments provided. Expected max ${totalCommands} but received ${length}.`);\n    }\n\n    parsed.demanded.forEach(demanded => {\n      const arg = args.shift();\n      const observedType = guessType(arg);\n      const matchingTypes = demanded.cmd.filter(type => type === observedType || type === '*');\n      if (matchingTypes.length === 0) argumentTypeError(observedType, demanded.cmd, position);\n      position += 1;\n    });\n    parsed.optional.forEach(optional => {\n      if (args.length === 0) return;\n      const arg = args.shift();\n      const observedType = guessType(arg);\n      const matchingTypes = optional.cmd.filter(type => type === observedType || type === '*');\n      if (matchingTypes.length === 0) argumentTypeError(observedType, optional.cmd, position);\n      position += 1;\n    });\n  } catch (err) {\n    console.warn(err.stack);\n  }\n}\n\nexports.argsert = argsert;\n\nfunction guessType(arg) {\n  if (Array.isArray(arg)) {\n    return 'array';\n  } else if (arg === null) {\n    return 'null';\n  }\n\n  return typeof arg;\n}\n\nfunction argumentTypeError(observedType, allowedTypes, position) {\n  throw new yerror_1.YError(`Invalid ${positionName[position] || 'manyith'} argument. Expected ${allowedTypes.join(' or ')} but received ${observedType}.`);\n}","map":{"version":3,"sources":["/Users/monika/Desktop/test/node_modules/yargs/build/lib/argsert.js"],"names":["Object","defineProperty","exports","value","argsert","yerror_1","require","parse_command_1","positionName","arg1","arg2","arg3","parseArgs","demanded","optional","parseCommand","position","parsed","callerArguments","length","args","slice","call","undefined","pop","YError","totalCommands","forEach","arg","shift","observedType","guessType","matchingTypes","cmd","filter","type","argumentTypeError","err","console","warn","stack","Array","isArray","allowedTypes","join"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.argsert = void 0;\nconst yerror_1 = require(\"./yerror\");\nconst parse_command_1 = require(\"./parse-command\");\nconst positionName = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth'];\nfunction argsert(arg1, arg2, arg3) {\n    function parseArgs() {\n        return typeof arg1 === 'object'\n            ? [{ demanded: [], optional: [] }, arg1, arg2]\n            : [parse_command_1.parseCommand(`cmd ${arg1}`), arg2, arg3];\n    }\n    // TODO: should this eventually raise an exception.\n    try {\n        // preface the argument description with \"cmd\", so\n        // that we can run it through yargs' command parser.\n        let position = 0;\n        let [parsed, callerArguments, length] = parseArgs();\n        const args = [].slice.call(callerArguments);\n        while (args.length && args[args.length - 1] === undefined)\n            args.pop();\n        length = length || args.length;\n        if (length < parsed.demanded.length) {\n            throw new yerror_1.YError(`Not enough arguments provided. Expected ${parsed.demanded.length} but received ${args.length}.`);\n        }\n        const totalCommands = parsed.demanded.length + parsed.optional.length;\n        if (length > totalCommands) {\n            throw new yerror_1.YError(`Too many arguments provided. Expected max ${totalCommands} but received ${length}.`);\n        }\n        parsed.demanded.forEach((demanded) => {\n            const arg = args.shift();\n            const observedType = guessType(arg);\n            const matchingTypes = demanded.cmd.filter(type => type === observedType || type === '*');\n            if (matchingTypes.length === 0)\n                argumentTypeError(observedType, demanded.cmd, position);\n            position += 1;\n        });\n        parsed.optional.forEach((optional) => {\n            if (args.length === 0)\n                return;\n            const arg = args.shift();\n            const observedType = guessType(arg);\n            const matchingTypes = optional.cmd.filter(type => type === observedType || type === '*');\n            if (matchingTypes.length === 0)\n                argumentTypeError(observedType, optional.cmd, position);\n            position += 1;\n        });\n    }\n    catch (err) {\n        console.warn(err.stack);\n    }\n}\nexports.argsert = argsert;\nfunction guessType(arg) {\n    if (Array.isArray(arg)) {\n        return 'array';\n    }\n    else if (arg === null) {\n        return 'null';\n    }\n    return typeof arg;\n}\nfunction argumentTypeError(observedType, allowedTypes, position) {\n    throw new yerror_1.YError(`Invalid ${positionName[position] || 'manyith'} argument. Expected ${allowedTypes.join(' or ')} but received ${observedType}.`);\n}\n"]},"metadata":{},"sourceType":"script"}