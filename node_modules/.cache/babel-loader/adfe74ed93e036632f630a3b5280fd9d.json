{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyExtends = void 0;\n\nconst fs = require(\"fs\");\n\nconst path = require(\"path\");\n\nconst yerror_1 = require(\"./yerror\");\n\nlet previouslyVisitedConfigs = [];\n\nfunction checkForCircularExtends(cfgPath) {\n  if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) {\n    throw new yerror_1.YError(`Circular extended configurations: '${cfgPath}'.`);\n  }\n}\n\nfunction getPathToDefaultConfig(cwd, pathToExtend) {\n  return path.resolve(cwd, pathToExtend);\n}\n\nfunction mergeDeep(config1, config2) {\n  const target = {};\n\n  function isObject(obj) {\n    return obj && typeof obj === 'object' && !Array.isArray(obj);\n  }\n\n  Object.assign(target, config1);\n\n  for (const key of Object.keys(config2)) {\n    if (isObject(config2[key]) && isObject(target[key])) {\n      target[key] = mergeDeep(config1[key], config2[key]);\n    } else {\n      target[key] = config2[key];\n    }\n  }\n\n  return target;\n}\n\nfunction applyExtends(config, cwd, mergeExtends = false) {\n  let defaultConfig = {};\n\n  if (Object.prototype.hasOwnProperty.call(config, 'extends')) {\n    if (typeof config.extends !== 'string') return defaultConfig;\n    const isPath = /\\.json|\\..*rc$/.test(config.extends);\n    let pathToDefault = null;\n\n    if (!isPath) {\n      try {\n        pathToDefault = require.resolve(config.extends);\n      } catch (err) {// most likely this simply isn't a module.\n      }\n    } else {\n      pathToDefault = getPathToDefaultConfig(cwd, config.extends);\n    } // maybe the module uses key for some other reason,\n    // err on side of caution.\n\n\n    if (!pathToDefault && !isPath) return config;\n    if (!pathToDefault) throw new yerror_1.YError(`Unable to find extended config '${config.extends}' in '${cwd}'.`);\n    checkForCircularExtends(pathToDefault);\n    previouslyVisitedConfigs.push(pathToDefault);\n    defaultConfig = isPath ? JSON.parse(fs.readFileSync(pathToDefault, 'utf8')) : require(config.extends);\n    delete config.extends;\n    defaultConfig = applyExtends(defaultConfig, path.dirname(pathToDefault), mergeExtends);\n  }\n\n  previouslyVisitedConfigs = [];\n  return mergeExtends ? mergeDeep(defaultConfig, config) : Object.assign({}, defaultConfig, config);\n}\n\nexports.applyExtends = applyExtends;","map":{"version":3,"sources":["/Users/monika/Desktop/test/node_modules/yargs/build/lib/apply-extends.js"],"names":["Object","defineProperty","exports","value","applyExtends","fs","require","path","yerror_1","previouslyVisitedConfigs","checkForCircularExtends","cfgPath","indexOf","YError","getPathToDefaultConfig","cwd","pathToExtend","resolve","mergeDeep","config1","config2","target","isObject","obj","Array","isArray","assign","key","keys","config","mergeExtends","defaultConfig","prototype","hasOwnProperty","call","extends","isPath","test","pathToDefault","err","push","JSON","parse","readFileSync","dirname"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applyExtends = void 0;\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst yerror_1 = require(\"./yerror\");\nlet previouslyVisitedConfigs = [];\nfunction checkForCircularExtends(cfgPath) {\n    if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) {\n        throw new yerror_1.YError(`Circular extended configurations: '${cfgPath}'.`);\n    }\n}\nfunction getPathToDefaultConfig(cwd, pathToExtend) {\n    return path.resolve(cwd, pathToExtend);\n}\nfunction mergeDeep(config1, config2) {\n    const target = {};\n    function isObject(obj) {\n        return obj && typeof obj === 'object' && !Array.isArray(obj);\n    }\n    Object.assign(target, config1);\n    for (const key of Object.keys(config2)) {\n        if (isObject(config2[key]) && isObject(target[key])) {\n            target[key] = mergeDeep(config1[key], config2[key]);\n        }\n        else {\n            target[key] = config2[key];\n        }\n    }\n    return target;\n}\nfunction applyExtends(config, cwd, mergeExtends = false) {\n    let defaultConfig = {};\n    if (Object.prototype.hasOwnProperty.call(config, 'extends')) {\n        if (typeof config.extends !== 'string')\n            return defaultConfig;\n        const isPath = /\\.json|\\..*rc$/.test(config.extends);\n        let pathToDefault = null;\n        if (!isPath) {\n            try {\n                pathToDefault = require.resolve(config.extends);\n            }\n            catch (err) {\n                // most likely this simply isn't a module.\n            }\n        }\n        else {\n            pathToDefault = getPathToDefaultConfig(cwd, config.extends);\n        }\n        // maybe the module uses key for some other reason,\n        // err on side of caution.\n        if (!pathToDefault && !isPath)\n            return config;\n        if (!pathToDefault)\n            throw new yerror_1.YError(`Unable to find extended config '${config.extends}' in '${cwd}'.`);\n        checkForCircularExtends(pathToDefault);\n        previouslyVisitedConfigs.push(pathToDefault);\n        defaultConfig = isPath ? JSON.parse(fs.readFileSync(pathToDefault, 'utf8')) : require(config.extends);\n        delete config.extends;\n        defaultConfig = applyExtends(defaultConfig, path.dirname(pathToDefault), mergeExtends);\n    }\n    previouslyVisitedConfigs = [];\n    return mergeExtends ? mergeDeep(defaultConfig, config) : Object.assign({}, defaultConfig, config);\n}\nexports.applyExtends = applyExtends;\n"]},"metadata":{},"sourceType":"script"}