{"ast":null,"code":"'use strict';\n\nconst pLimit = require('p-limit');\n\nclass EndError extends Error {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n\n} // The input can also be a promise, so we await it\n\n\nconst testElement = async (element, tester) => tester(await element); // The input can also be a promise, so we `Promise.all()` them both\n\n\nconst finder = async element => {\n  const values = await Promise.all(element);\n\n  if (values[1] === true) {\n    throw new EndError(values[0]);\n  }\n\n  return false;\n};\n\nconst pLocate = async (iterable, tester, options) => {\n  options = {\n    concurrency: Infinity,\n    preserveOrder: true,\n    ...options\n  };\n  const limit = pLimit(options.concurrency); // Start all the promises concurrently with optional limit\n\n  const items = [...iterable].map(element => [element, limit(testElement, element, tester)]); // Check the promises either serially or concurrently\n\n  const checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);\n\n  try {\n    await Promise.all(items.map(element => checkLimit(finder, element)));\n  } catch (error) {\n    if (error instanceof EndError) {\n      return error.value;\n    }\n\n    throw error;\n  }\n};\n\nmodule.exports = pLocate; // TODO: Remove this for the next major release\n\nmodule.exports.default = pLocate;","map":{"version":3,"sources":["/Users/monika/Desktop/test/node_modules/p-locate/index.js"],"names":["pLimit","require","EndError","Error","constructor","value","testElement","element","tester","finder","values","Promise","all","pLocate","iterable","options","concurrency","Infinity","preserveOrder","limit","items","map","checkLimit","error","module","exports","default"],"mappings":"AAAA;;AACA,MAAMA,MAAM,GAAGC,OAAO,CAAC,SAAD,CAAtB;;AAEA,MAAMC,QAAN,SAAuBC,KAAvB,CAA6B;AAC5BC,EAAAA,WAAW,CAACC,KAAD,EAAQ;AAClB;AACA,SAAKA,KAAL,GAAaA,KAAb;AACA;;AAJ2B,C,CAO7B;;;AACA,MAAMC,WAAW,GAAG,OAAOC,OAAP,EAAgBC,MAAhB,KAA2BA,MAAM,CAAC,MAAMD,OAAP,CAArD,C,CAEA;;;AACA,MAAME,MAAM,GAAG,MAAMF,OAAN,IAAiB;AAC/B,QAAMG,MAAM,GAAG,MAAMC,OAAO,CAACC,GAAR,CAAYL,OAAZ,CAArB;;AACA,MAAIG,MAAM,CAAC,CAAD,CAAN,KAAc,IAAlB,EAAwB;AACvB,UAAM,IAAIR,QAAJ,CAAaQ,MAAM,CAAC,CAAD,CAAnB,CAAN;AACA;;AAED,SAAO,KAAP;AACA,CAPD;;AASA,MAAMG,OAAO,GAAG,OAAOC,QAAP,EAAiBN,MAAjB,EAAyBO,OAAzB,KAAqC;AACpDA,EAAAA,OAAO,GAAG;AACTC,IAAAA,WAAW,EAAEC,QADJ;AAETC,IAAAA,aAAa,EAAE,IAFN;AAGT,OAAGH;AAHM,GAAV;AAMA,QAAMI,KAAK,GAAGnB,MAAM,CAACe,OAAO,CAACC,WAAT,CAApB,CAPoD,CASpD;;AACA,QAAMI,KAAK,GAAG,CAAC,GAAGN,QAAJ,EAAcO,GAAd,CAAkBd,OAAO,IAAI,CAACA,OAAD,EAAUY,KAAK,CAACb,WAAD,EAAcC,OAAd,EAAuBC,MAAvB,CAAf,CAA7B,CAAd,CAVoD,CAYpD;;AACA,QAAMc,UAAU,GAAGtB,MAAM,CAACe,OAAO,CAACG,aAAR,GAAwB,CAAxB,GAA4BD,QAA7B,CAAzB;;AAEA,MAAI;AACH,UAAMN,OAAO,CAACC,GAAR,CAAYQ,KAAK,CAACC,GAAN,CAAUd,OAAO,IAAIe,UAAU,CAACb,MAAD,EAASF,OAAT,CAA/B,CAAZ,CAAN;AACA,GAFD,CAEE,OAAOgB,KAAP,EAAc;AACf,QAAIA,KAAK,YAAYrB,QAArB,EAA+B;AAC9B,aAAOqB,KAAK,CAAClB,KAAb;AACA;;AAED,UAAMkB,KAAN;AACA;AACD,CAxBD;;AA0BAC,MAAM,CAACC,OAAP,GAAiBZ,OAAjB,C,CACA;;AACAW,MAAM,CAACC,OAAP,CAAeC,OAAf,GAAyBb,OAAzB","sourcesContent":["'use strict';\nconst pLimit = require('p-limit');\n\nclass EndError extends Error {\n\tconstructor(value) {\n\t\tsuper();\n\t\tthis.value = value;\n\t}\n}\n\n// The input can also be a promise, so we await it\nconst testElement = async (element, tester) => tester(await element);\n\n// The input can also be a promise, so we `Promise.all()` them both\nconst finder = async element => {\n\tconst values = await Promise.all(element);\n\tif (values[1] === true) {\n\t\tthrow new EndError(values[0]);\n\t}\n\n\treturn false;\n};\n\nconst pLocate = async (iterable, tester, options) => {\n\toptions = {\n\t\tconcurrency: Infinity,\n\t\tpreserveOrder: true,\n\t\t...options\n\t};\n\n\tconst limit = pLimit(options.concurrency);\n\n\t// Start all the promises concurrently with optional limit\n\tconst items = [...iterable].map(element => [element, limit(testElement, element, tester)]);\n\n\t// Check the promises either serially or concurrently\n\tconst checkLimit = pLimit(options.preserveOrder ? 1 : Infinity);\n\n\ttry {\n\t\tawait Promise.all(items.map(element => checkLimit(finder, element)));\n\t} catch (error) {\n\t\tif (error instanceof EndError) {\n\t\t\treturn error.value;\n\t\t}\n\n\t\tthrow error;\n\t}\n};\n\nmodule.exports = pLocate;\n// TODO: Remove this for the next major release\nmodule.exports.default = pLocate;\n"]},"metadata":{},"sourceType":"script"}