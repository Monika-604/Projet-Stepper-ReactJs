{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isCommandBuilderCallback = exports.isCommandBuilderDefinition = exports.isCommandHandlerDefinition = exports.command = void 0;\n\nconst common_types_1 = require(\"./common-types\");\n\nconst is_promise_1 = require(\"./is-promise\");\n\nconst middleware_1 = require(\"./middleware\");\n\nconst parse_command_1 = require(\"./parse-command\");\n\nconst path = require(\"path\");\n\nconst util_1 = require(\"util\");\n\nconst yargs_1 = require(\"./yargs\");\n\nconst requireDirectory = require(\"require-directory\");\n\nconst whichModule = require(\"which-module\");\n\nconst Parser = require(\"yargs-parser\");\n\nconst DEFAULT_MARKER = /(^\\*)|(^\\$0)/; // handles parsing positional arguments,\n// and populating argv with said positional\n// arguments.\n\nfunction command(yargs, usage, validation, globalMiddleware = []) {\n  const self = {};\n  let handlers = {};\n  let aliasMap = {};\n  let defaultCommand;\n\n  self.addHandler = function addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) {\n    let aliases = [];\n    const middlewares = middleware_1.commandMiddlewareFactory(commandMiddleware);\n\n    handler = handler || (() => {});\n\n    if (Array.isArray(cmd)) {\n      aliases = cmd.slice(1);\n      cmd = cmd[0];\n    } else if (isCommandHandlerDefinition(cmd)) {\n      let command = Array.isArray(cmd.command) || typeof cmd.command === 'string' ? cmd.command : moduleName(cmd);\n      if (cmd.aliases) command = [].concat(command).concat(cmd.aliases);\n      self.addHandler(command, extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares, cmd.deprecated);\n      return;\n    } // allow a module to be provided instead of separate builder and handler\n\n\n    if (isCommandBuilderDefinition(builder)) {\n      self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares, builder.deprecated);\n      return;\n    } // parse positionals out of cmd string\n\n\n    const parsedCommand = parse_command_1.parseCommand(cmd); // remove positional args from aliases only\n\n    aliases = aliases.map(alias => parse_command_1.parseCommand(alias).cmd); // check for default and filter out '*''\n\n    let isDefault = false;\n    const parsedAliases = [parsedCommand.cmd].concat(aliases).filter(c => {\n      if (DEFAULT_MARKER.test(c)) {\n        isDefault = true;\n        return false;\n      }\n\n      return true;\n    }); // standardize on $0 for default command.\n\n    if (parsedAliases.length === 0 && isDefault) parsedAliases.push('$0'); // shift cmd and aliases after filtering out '*'\n\n    if (isDefault) {\n      parsedCommand.cmd = parsedAliases[0];\n      aliases = parsedAliases.slice(1);\n      cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);\n    } // populate aliasMap\n\n\n    aliases.forEach(alias => {\n      aliasMap[alias] = parsedCommand.cmd;\n    });\n\n    if (description !== false) {\n      usage.command(cmd, description, isDefault, aliases, deprecated);\n    }\n\n    handlers[parsedCommand.cmd] = {\n      original: cmd,\n      description,\n      handler,\n      builder: builder || {},\n      middlewares,\n      deprecated,\n      demanded: parsedCommand.demanded,\n      optional: parsedCommand.optional\n    };\n    if (isDefault) defaultCommand = handlers[parsedCommand.cmd];\n  };\n\n  self.addDirectory = function addDirectory(dir, context, req, callerFile, opts) {\n    opts = opts || {}; // disable recursion to support nested directories of subcommands\n\n    if (typeof opts.recurse !== 'boolean') opts.recurse = false; // exclude 'json', 'coffee' from require-directory defaults\n\n    if (!Array.isArray(opts.extensions)) opts.extensions = ['js']; // allow consumer to define their own visitor function\n\n    const parentVisit = typeof opts.visit === 'function' ? opts.visit : o => o; // call addHandler via visitor function\n\n    opts.visit = function visit(obj, joined, filename) {\n      const visited = parentVisit(obj, joined, filename); // allow consumer to skip modules with their own visitor\n\n      if (visited) {\n        // check for cyclic reference\n        // each command file path should only be seen once per execution\n        if (~context.files.indexOf(joined)) return visited; // keep track of visited files in context.files\n\n        context.files.push(joined);\n        self.addHandler(visited);\n      }\n\n      return visited;\n    };\n\n    requireDirectory({\n      require: req,\n      filename: callerFile\n    }, dir, opts);\n  }; // lookup module object from require()d command and derive name\n  // if module was not require()d and no name given, throw error\n\n\n  function moduleName(obj) {\n    const mod = whichModule(obj);\n    if (!mod) throw new Error(`No command name given for module: ${util_1.inspect(obj)}`);\n    return commandFromFilename(mod.filename);\n  } // derive command name from filename\n\n\n  function commandFromFilename(filename) {\n    return path.basename(filename, path.extname(filename));\n  }\n\n  function extractDesc({\n    describe,\n    description,\n    desc\n  }) {\n    for (const test of [describe, description, desc]) {\n      if (typeof test === 'string' || test === false) return test;\n      common_types_1.assertNotStrictEqual(test, true);\n    }\n\n    return false;\n  }\n\n  self.getCommands = () => Object.keys(handlers).concat(Object.keys(aliasMap));\n\n  self.getCommandHandlers = () => handlers;\n\n  self.hasDefaultCommand = () => !!defaultCommand;\n\n  self.runCommand = function runCommand(command, yargs, parsed, commandIndex) {\n    let aliases = parsed.aliases;\n    const commandHandler = handlers[command] || handlers[aliasMap[command]] || defaultCommand;\n    const currentContext = yargs.getContext();\n    let numFiles = currentContext.files.length;\n    const parentCommands = currentContext.commands.slice(); // what does yargs look like after the builder is run?\n\n    let innerArgv = parsed.argv;\n    let positionalMap = {};\n\n    if (command) {\n      currentContext.commands.push(command);\n      currentContext.fullCommands.push(commandHandler.original);\n    }\n\n    const builder = commandHandler.builder;\n\n    if (isCommandBuilderCallback(builder)) {\n      // a function can be provided, which builds\n      // up a yargs chain and possibly returns it.\n      const builderOutput = builder(yargs.reset(parsed.aliases));\n      const innerYargs = yargs_1.isYargsInstance(builderOutput) ? builderOutput : yargs;\n\n      if (shouldUpdateUsage(innerYargs)) {\n        innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);\n      }\n\n      innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);\n      aliases = innerYargs.parsed.aliases;\n    } else if (isCommandBuilderOptionDefinitions(builder)) {\n      // as a short hand, an object can instead be provided, specifying\n      // the options that a command takes.\n      const innerYargs = yargs.reset(parsed.aliases);\n\n      if (shouldUpdateUsage(innerYargs)) {\n        innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);\n      }\n\n      Object.keys(commandHandler.builder).forEach(key => {\n        innerYargs.option(key, builder[key]);\n      });\n      innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);\n      aliases = innerYargs.parsed.aliases;\n    }\n\n    if (!yargs._hasOutput()) {\n      positionalMap = populatePositionals(commandHandler, innerArgv, currentContext);\n    }\n\n    const middlewares = globalMiddleware.slice(0).concat(commandHandler.middlewares);\n    middleware_1.applyMiddleware(innerArgv, yargs, middlewares, true); // we apply validation post-hoc, so that custom\n    // checks get passed populated positional arguments.\n\n    if (!yargs._hasOutput()) {\n      yargs._runValidation(innerArgv, aliases, positionalMap, yargs.parsed.error, !command);\n    }\n\n    if (commandHandler.handler && !yargs._hasOutput()) {\n      yargs._setHasOutput(); // to simplify the parsing of positionals in commands,\n      // we temporarily populate '--' rather than _, with arguments\n\n\n      const populateDoubleDash = !!yargs.getOptions().configuration['populate--'];\n      if (!populateDoubleDash) yargs._copyDoubleDash(innerArgv);\n      innerArgv = middleware_1.applyMiddleware(innerArgv, yargs, middlewares, false);\n      let handlerResult;\n\n      if (is_promise_1.isPromise(innerArgv)) {\n        handlerResult = innerArgv.then(argv => commandHandler.handler(argv));\n      } else {\n        handlerResult = commandHandler.handler(innerArgv);\n      }\n\n      const handlerFinishCommand = yargs.getHandlerFinishCommand();\n\n      if (is_promise_1.isPromise(handlerResult)) {\n        yargs.getUsageInstance().cacheHelpMessage();\n        handlerResult.then(value => {\n          if (handlerFinishCommand) {\n            handlerFinishCommand(value);\n          }\n        }).catch(error => {\n          try {\n            yargs.getUsageInstance().fail(null, error);\n          } catch (err) {// fail's throwing would cause an unhandled rejection.\n          }\n        }).then(() => {\n          yargs.getUsageInstance().clearCachedHelpMessage();\n        });\n      } else {\n        if (handlerFinishCommand) {\n          handlerFinishCommand(handlerResult);\n        }\n      }\n    }\n\n    if (command) {\n      currentContext.commands.pop();\n      currentContext.fullCommands.pop();\n    }\n\n    numFiles = currentContext.files.length - numFiles;\n    if (numFiles > 0) currentContext.files.splice(numFiles * -1, numFiles);\n    return innerArgv;\n  };\n\n  function shouldUpdateUsage(yargs) {\n    return !yargs.getUsageInstance().getUsageDisabled() && yargs.getUsageInstance().getUsage().length === 0;\n  }\n\n  function usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {\n    const c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, '').trim() : commandHandler.original;\n    const pc = parentCommands.filter(c => {\n      return !DEFAULT_MARKER.test(c);\n    });\n    pc.push(c);\n    return `$0 ${pc.join(' ')}`;\n  }\n\n  self.runDefaultBuilderOn = function (yargs) {\n    common_types_1.assertNotStrictEqual(defaultCommand, undefined);\n\n    if (shouldUpdateUsage(yargs)) {\n      // build the root-level command string from the default string.\n      const commandString = DEFAULT_MARKER.test(defaultCommand.original) ? defaultCommand.original : defaultCommand.original.replace(/^[^[\\]<>]*/, '$0 ');\n      yargs.getUsageInstance().usage(commandString, defaultCommand.description);\n    }\n\n    const builder = defaultCommand.builder;\n\n    if (isCommandBuilderCallback(builder)) {\n      builder(yargs);\n    } else {\n      Object.keys(builder).forEach(key => {\n        yargs.option(key, builder[key]);\n      });\n    }\n  }; // transcribe all positional arguments \"command <foo> <bar> [apple]\"\n  // onto argv.\n\n\n  function populatePositionals(commandHandler, argv, context) {\n    argv._ = argv._.slice(context.commands.length); // nuke the current commands\n\n    const demanded = commandHandler.demanded.slice(0);\n    const optional = commandHandler.optional.slice(0);\n    const positionalMap = {};\n    validation.positionalCount(demanded.length, argv._.length);\n\n    while (demanded.length) {\n      const demand = demanded.shift();\n      populatePositional(demand, argv, positionalMap);\n    }\n\n    while (optional.length) {\n      const maybe = optional.shift();\n      populatePositional(maybe, argv, positionalMap);\n    }\n\n    argv._ = context.commands.concat(argv._);\n    postProcessPositionals(argv, positionalMap, self.cmdToParseOptions(commandHandler.original));\n    return positionalMap;\n  }\n\n  function populatePositional(positional, argv, positionalMap) {\n    const cmd = positional.cmd[0];\n\n    if (positional.variadic) {\n      positionalMap[cmd] = argv._.splice(0).map(String);\n    } else {\n      if (argv._.length) positionalMap[cmd] = [String(argv._.shift())];\n    }\n  } // we run yargs-parser against the positional arguments\n  // applying the same parsing logic used for flags.\n\n\n  function postProcessPositionals(argv, positionalMap, parseOptions) {\n    // combine the parsing hints we've inferred from the command\n    // string with explicitly configured parsing hints.\n    const options = Object.assign({}, yargs.getOptions());\n    options.default = Object.assign(parseOptions.default, options.default);\n\n    for (const key of Object.keys(parseOptions.alias)) {\n      options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);\n    }\n\n    options.array = options.array.concat(parseOptions.array);\n    delete options.config; //  don't load config when processing positionals.\n\n    const unparsed = [];\n    Object.keys(positionalMap).forEach(key => {\n      positionalMap[key].map(value => {\n        if (options.configuration['unknown-options-as-args']) options.key[key] = true;\n        unparsed.push(`--${key}`);\n        unparsed.push(value);\n      });\n    }); // short-circuit parse.\n\n    if (!unparsed.length) return;\n    const config = Object.assign({}, options.configuration, {\n      'populate--': true\n    });\n    const parsed = Parser.detailed(unparsed, Object.assign({}, options, {\n      configuration: config\n    }));\n\n    if (parsed.error) {\n      yargs.getUsageInstance().fail(parsed.error.message, parsed.error);\n    } else {\n      // only copy over positional keys (don't overwrite\n      // flag arguments that were already parsed).\n      const positionalKeys = Object.keys(positionalMap);\n      Object.keys(positionalMap).forEach(key => {\n        positionalKeys.push(...parsed.aliases[key]);\n      });\n      Object.keys(parsed.argv).forEach(key => {\n        if (positionalKeys.indexOf(key) !== -1) {\n          // any new aliases need to be placed in positionalMap, which\n          // is used for validation.\n          if (!positionalMap[key]) positionalMap[key] = parsed.argv[key];\n          argv[key] = parsed.argv[key];\n        }\n      });\n    }\n  }\n\n  self.cmdToParseOptions = function (cmdString) {\n    const parseOptions = {\n      array: [],\n      default: {},\n      alias: {},\n      demand: {}\n    };\n    const parsed = parse_command_1.parseCommand(cmdString);\n    parsed.demanded.forEach(d => {\n      const [cmd, ...aliases] = d.cmd;\n\n      if (d.variadic) {\n        parseOptions.array.push(cmd);\n        parseOptions.default[cmd] = [];\n      }\n\n      parseOptions.alias[cmd] = aliases;\n      parseOptions.demand[cmd] = true;\n    });\n    parsed.optional.forEach(o => {\n      const [cmd, ...aliases] = o.cmd;\n\n      if (o.variadic) {\n        parseOptions.array.push(cmd);\n        parseOptions.default[cmd] = [];\n      }\n\n      parseOptions.alias[cmd] = aliases;\n    });\n    return parseOptions;\n  };\n\n  self.reset = () => {\n    handlers = {};\n    aliasMap = {};\n    defaultCommand = undefined;\n    return self;\n  }; // used by yargs.parse() to freeze\n  // the state of commands such that\n  // we can apply .parse() multiple times\n  // with the same yargs instance.\n\n\n  const frozens = [];\n\n  self.freeze = () => {\n    frozens.push({\n      handlers,\n      aliasMap,\n      defaultCommand\n    });\n  };\n\n  self.unfreeze = () => {\n    const frozen = frozens.pop();\n    common_types_1.assertNotStrictEqual(frozen, undefined);\n    ({\n      handlers,\n      aliasMap,\n      defaultCommand\n    } = frozen);\n  };\n\n  return self;\n}\n\nexports.command = command;\n\nfunction isCommandHandlerDefinition(cmd) {\n  return typeof cmd === 'object';\n}\n\nexports.isCommandHandlerDefinition = isCommandHandlerDefinition;\n\nfunction isCommandBuilderDefinition(builder) {\n  return typeof builder === 'object' && !!builder.builder && typeof builder.handler === 'function';\n}\n\nexports.isCommandBuilderDefinition = isCommandBuilderDefinition;\n\nfunction isCommandBuilderCallback(builder) {\n  return typeof builder === 'function';\n}\n\nexports.isCommandBuilderCallback = isCommandBuilderCallback;\n\nfunction isCommandBuilderOptionDefinitions(builder) {\n  return typeof builder === 'object';\n}","map":{"version":3,"sources":["/Users/monika/Desktop/test/node_modules/yargs/build/lib/command.js"],"names":["Object","defineProperty","exports","value","isCommandBuilderCallback","isCommandBuilderDefinition","isCommandHandlerDefinition","command","common_types_1","require","is_promise_1","middleware_1","parse_command_1","path","util_1","yargs_1","requireDirectory","whichModule","Parser","DEFAULT_MARKER","yargs","usage","validation","globalMiddleware","self","handlers","aliasMap","defaultCommand","addHandler","cmd","description","builder","handler","commandMiddleware","deprecated","aliases","middlewares","commandMiddlewareFactory","Array","isArray","slice","moduleName","concat","extractDesc","parsedCommand","parseCommand","map","alias","isDefault","parsedAliases","filter","c","test","length","push","replace","forEach","original","demanded","optional","addDirectory","dir","context","req","callerFile","opts","recurse","extensions","parentVisit","visit","o","obj","joined","filename","visited","files","indexOf","mod","Error","inspect","commandFromFilename","basename","extname","describe","desc","assertNotStrictEqual","getCommands","keys","getCommandHandlers","hasDefaultCommand","runCommand","parsed","commandIndex","commandHandler","currentContext","getContext","numFiles","parentCommands","commands","innerArgv","argv","positionalMap","fullCommands","builderOutput","reset","innerYargs","isYargsInstance","shouldUpdateUsage","getUsageInstance","usageFromParentCommandsCommandHandler","_parseArgs","isCommandBuilderOptionDefinitions","key","option","_hasOutput","populatePositionals","applyMiddleware","_runValidation","error","_setHasOutput","populateDoubleDash","getOptions","configuration","_copyDoubleDash","handlerResult","isPromise","then","handlerFinishCommand","getHandlerFinishCommand","cacheHelpMessage","catch","fail","err","clearCachedHelpMessage","pop","splice","getUsageDisabled","getUsage","trim","pc","join","runDefaultBuilderOn","undefined","commandString","_","positionalCount","demand","shift","populatePositional","maybe","postProcessPositionals","cmdToParseOptions","positional","variadic","String","parseOptions","options","assign","default","array","config","unparsed","detailed","message","positionalKeys","cmdString","d","frozens","freeze","unfreeze","frozen"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isCommandBuilderCallback = exports.isCommandBuilderDefinition = exports.isCommandHandlerDefinition = exports.command = void 0;\nconst common_types_1 = require(\"./common-types\");\nconst is_promise_1 = require(\"./is-promise\");\nconst middleware_1 = require(\"./middleware\");\nconst parse_command_1 = require(\"./parse-command\");\nconst path = require(\"path\");\nconst util_1 = require(\"util\");\nconst yargs_1 = require(\"./yargs\");\nconst requireDirectory = require(\"require-directory\");\nconst whichModule = require(\"which-module\");\nconst Parser = require(\"yargs-parser\");\nconst DEFAULT_MARKER = /(^\\*)|(^\\$0)/;\n// handles parsing positional arguments,\n// and populating argv with said positional\n// arguments.\nfunction command(yargs, usage, validation, globalMiddleware = []) {\n    const self = {};\n    let handlers = {};\n    let aliasMap = {};\n    let defaultCommand;\n    self.addHandler = function addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) {\n        let aliases = [];\n        const middlewares = middleware_1.commandMiddlewareFactory(commandMiddleware);\n        handler = handler || (() => { });\n        if (Array.isArray(cmd)) {\n            aliases = cmd.slice(1);\n            cmd = cmd[0];\n        }\n        else if (isCommandHandlerDefinition(cmd)) {\n            let command = (Array.isArray(cmd.command) || typeof cmd.command === 'string') ? cmd.command : moduleName(cmd);\n            if (cmd.aliases)\n                command = [].concat(command).concat(cmd.aliases);\n            self.addHandler(command, extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares, cmd.deprecated);\n            return;\n        }\n        // allow a module to be provided instead of separate builder and handler\n        if (isCommandBuilderDefinition(builder)) {\n            self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares, builder.deprecated);\n            return;\n        }\n        // parse positionals out of cmd string\n        const parsedCommand = parse_command_1.parseCommand(cmd);\n        // remove positional args from aliases only\n        aliases = aliases.map(alias => parse_command_1.parseCommand(alias).cmd);\n        // check for default and filter out '*''\n        let isDefault = false;\n        const parsedAliases = [parsedCommand.cmd].concat(aliases).filter((c) => {\n            if (DEFAULT_MARKER.test(c)) {\n                isDefault = true;\n                return false;\n            }\n            return true;\n        });\n        // standardize on $0 for default command.\n        if (parsedAliases.length === 0 && isDefault)\n            parsedAliases.push('$0');\n        // shift cmd and aliases after filtering out '*'\n        if (isDefault) {\n            parsedCommand.cmd = parsedAliases[0];\n            aliases = parsedAliases.slice(1);\n            cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);\n        }\n        // populate aliasMap\n        aliases.forEach((alias) => {\n            aliasMap[alias] = parsedCommand.cmd;\n        });\n        if (description !== false) {\n            usage.command(cmd, description, isDefault, aliases, deprecated);\n        }\n        handlers[parsedCommand.cmd] = {\n            original: cmd,\n            description,\n            handler,\n            builder: builder || {},\n            middlewares,\n            deprecated,\n            demanded: parsedCommand.demanded,\n            optional: parsedCommand.optional\n        };\n        if (isDefault)\n            defaultCommand = handlers[parsedCommand.cmd];\n    };\n    self.addDirectory = function addDirectory(dir, context, req, callerFile, opts) {\n        opts = opts || {};\n        // disable recursion to support nested directories of subcommands\n        if (typeof opts.recurse !== 'boolean')\n            opts.recurse = false;\n        // exclude 'json', 'coffee' from require-directory defaults\n        if (!Array.isArray(opts.extensions))\n            opts.extensions = ['js'];\n        // allow consumer to define their own visitor function\n        const parentVisit = typeof opts.visit === 'function' ? opts.visit : (o) => o;\n        // call addHandler via visitor function\n        opts.visit = function visit(obj, joined, filename) {\n            const visited = parentVisit(obj, joined, filename);\n            // allow consumer to skip modules with their own visitor\n            if (visited) {\n                // check for cyclic reference\n                // each command file path should only be seen once per execution\n                if (~context.files.indexOf(joined))\n                    return visited;\n                // keep track of visited files in context.files\n                context.files.push(joined);\n                self.addHandler(visited);\n            }\n            return visited;\n        };\n        requireDirectory({ require: req, filename: callerFile }, dir, opts);\n    };\n    // lookup module object from require()d command and derive name\n    // if module was not require()d and no name given, throw error\n    function moduleName(obj) {\n        const mod = whichModule(obj);\n        if (!mod)\n            throw new Error(`No command name given for module: ${util_1.inspect(obj)}`);\n        return commandFromFilename(mod.filename);\n    }\n    // derive command name from filename\n    function commandFromFilename(filename) {\n        return path.basename(filename, path.extname(filename));\n    }\n    function extractDesc({ describe, description, desc }) {\n        for (const test of [describe, description, desc]) {\n            if (typeof test === 'string' || test === false)\n                return test;\n            common_types_1.assertNotStrictEqual(test, true);\n        }\n        return false;\n    }\n    self.getCommands = () => Object.keys(handlers).concat(Object.keys(aliasMap));\n    self.getCommandHandlers = () => handlers;\n    self.hasDefaultCommand = () => !!defaultCommand;\n    self.runCommand = function runCommand(command, yargs, parsed, commandIndex) {\n        let aliases = parsed.aliases;\n        const commandHandler = handlers[command] || handlers[aliasMap[command]] || defaultCommand;\n        const currentContext = yargs.getContext();\n        let numFiles = currentContext.files.length;\n        const parentCommands = currentContext.commands.slice();\n        // what does yargs look like after the builder is run?\n        let innerArgv = parsed.argv;\n        let positionalMap = {};\n        if (command) {\n            currentContext.commands.push(command);\n            currentContext.fullCommands.push(commandHandler.original);\n        }\n        const builder = commandHandler.builder;\n        if (isCommandBuilderCallback(builder)) {\n            // a function can be provided, which builds\n            // up a yargs chain and possibly returns it.\n            const builderOutput = builder(yargs.reset(parsed.aliases));\n            const innerYargs = yargs_1.isYargsInstance(builderOutput) ? builderOutput : yargs;\n            if (shouldUpdateUsage(innerYargs)) {\n                innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);\n            }\n            innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);\n            aliases = innerYargs.parsed.aliases;\n        }\n        else if (isCommandBuilderOptionDefinitions(builder)) {\n            // as a short hand, an object can instead be provided, specifying\n            // the options that a command takes.\n            const innerYargs = yargs.reset(parsed.aliases);\n            if (shouldUpdateUsage(innerYargs)) {\n                innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);\n            }\n            Object.keys(commandHandler.builder).forEach((key) => {\n                innerYargs.option(key, builder[key]);\n            });\n            innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);\n            aliases = innerYargs.parsed.aliases;\n        }\n        if (!yargs._hasOutput()) {\n            positionalMap = populatePositionals(commandHandler, innerArgv, currentContext);\n        }\n        const middlewares = globalMiddleware.slice(0).concat(commandHandler.middlewares);\n        middleware_1.applyMiddleware(innerArgv, yargs, middlewares, true);\n        // we apply validation post-hoc, so that custom\n        // checks get passed populated positional arguments.\n        if (!yargs._hasOutput()) {\n            yargs._runValidation(innerArgv, aliases, positionalMap, yargs.parsed.error, !command);\n        }\n        if (commandHandler.handler && !yargs._hasOutput()) {\n            yargs._setHasOutput();\n            // to simplify the parsing of positionals in commands,\n            // we temporarily populate '--' rather than _, with arguments\n            const populateDoubleDash = !!yargs.getOptions().configuration['populate--'];\n            if (!populateDoubleDash)\n                yargs._copyDoubleDash(innerArgv);\n            innerArgv = middleware_1.applyMiddleware(innerArgv, yargs, middlewares, false);\n            let handlerResult;\n            if (is_promise_1.isPromise(innerArgv)) {\n                handlerResult = innerArgv.then(argv => commandHandler.handler(argv));\n            }\n            else {\n                handlerResult = commandHandler.handler(innerArgv);\n            }\n            const handlerFinishCommand = yargs.getHandlerFinishCommand();\n            if (is_promise_1.isPromise(handlerResult)) {\n                yargs.getUsageInstance().cacheHelpMessage();\n                handlerResult\n                    .then(value => {\n                    if (handlerFinishCommand) {\n                        handlerFinishCommand(value);\n                    }\n                })\n                    .catch(error => {\n                    try {\n                        yargs.getUsageInstance().fail(null, error);\n                    }\n                    catch (err) {\n                        // fail's throwing would cause an unhandled rejection.\n                    }\n                })\n                    .then(() => {\n                    yargs.getUsageInstance().clearCachedHelpMessage();\n                });\n            }\n            else {\n                if (handlerFinishCommand) {\n                    handlerFinishCommand(handlerResult);\n                }\n            }\n        }\n        if (command) {\n            currentContext.commands.pop();\n            currentContext.fullCommands.pop();\n        }\n        numFiles = currentContext.files.length - numFiles;\n        if (numFiles > 0)\n            currentContext.files.splice(numFiles * -1, numFiles);\n        return innerArgv;\n    };\n    function shouldUpdateUsage(yargs) {\n        return !yargs.getUsageInstance().getUsageDisabled() &&\n            yargs.getUsageInstance().getUsage().length === 0;\n    }\n    function usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {\n        const c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, '').trim() : commandHandler.original;\n        const pc = parentCommands.filter((c) => { return !DEFAULT_MARKER.test(c); });\n        pc.push(c);\n        return `$0 ${pc.join(' ')}`;\n    }\n    self.runDefaultBuilderOn = function (yargs) {\n        common_types_1.assertNotStrictEqual(defaultCommand, undefined);\n        if (shouldUpdateUsage(yargs)) {\n            // build the root-level command string from the default string.\n            const commandString = DEFAULT_MARKER.test(defaultCommand.original)\n                ? defaultCommand.original : defaultCommand.original.replace(/^[^[\\]<>]*/, '$0 ');\n            yargs.getUsageInstance().usage(commandString, defaultCommand.description);\n        }\n        const builder = defaultCommand.builder;\n        if (isCommandBuilderCallback(builder)) {\n            builder(yargs);\n        }\n        else {\n            Object.keys(builder).forEach((key) => {\n                yargs.option(key, builder[key]);\n            });\n        }\n    };\n    // transcribe all positional arguments \"command <foo> <bar> [apple]\"\n    // onto argv.\n    function populatePositionals(commandHandler, argv, context) {\n        argv._ = argv._.slice(context.commands.length); // nuke the current commands\n        const demanded = commandHandler.demanded.slice(0);\n        const optional = commandHandler.optional.slice(0);\n        const positionalMap = {};\n        validation.positionalCount(demanded.length, argv._.length);\n        while (demanded.length) {\n            const demand = demanded.shift();\n            populatePositional(demand, argv, positionalMap);\n        }\n        while (optional.length) {\n            const maybe = optional.shift();\n            populatePositional(maybe, argv, positionalMap);\n        }\n        argv._ = context.commands.concat(argv._);\n        postProcessPositionals(argv, positionalMap, self.cmdToParseOptions(commandHandler.original));\n        return positionalMap;\n    }\n    function populatePositional(positional, argv, positionalMap) {\n        const cmd = positional.cmd[0];\n        if (positional.variadic) {\n            positionalMap[cmd] = argv._.splice(0).map(String);\n        }\n        else {\n            if (argv._.length)\n                positionalMap[cmd] = [String(argv._.shift())];\n        }\n    }\n    // we run yargs-parser against the positional arguments\n    // applying the same parsing logic used for flags.\n    function postProcessPositionals(argv, positionalMap, parseOptions) {\n        // combine the parsing hints we've inferred from the command\n        // string with explicitly configured parsing hints.\n        const options = Object.assign({}, yargs.getOptions());\n        options.default = Object.assign(parseOptions.default, options.default);\n        for (const key of Object.keys(parseOptions.alias)) {\n            options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);\n        }\n        options.array = options.array.concat(parseOptions.array);\n        delete options.config; //  don't load config when processing positionals.\n        const unparsed = [];\n        Object.keys(positionalMap).forEach((key) => {\n            positionalMap[key].map((value) => {\n                if (options.configuration['unknown-options-as-args'])\n                    options.key[key] = true;\n                unparsed.push(`--${key}`);\n                unparsed.push(value);\n            });\n        });\n        // short-circuit parse.\n        if (!unparsed.length)\n            return;\n        const config = Object.assign({}, options.configuration, {\n            'populate--': true\n        });\n        const parsed = Parser.detailed(unparsed, Object.assign({}, options, {\n            configuration: config\n        }));\n        if (parsed.error) {\n            yargs.getUsageInstance().fail(parsed.error.message, parsed.error);\n        }\n        else {\n            // only copy over positional keys (don't overwrite\n            // flag arguments that were already parsed).\n            const positionalKeys = Object.keys(positionalMap);\n            Object.keys(positionalMap).forEach((key) => {\n                positionalKeys.push(...parsed.aliases[key]);\n            });\n            Object.keys(parsed.argv).forEach((key) => {\n                if (positionalKeys.indexOf(key) !== -1) {\n                    // any new aliases need to be placed in positionalMap, which\n                    // is used for validation.\n                    if (!positionalMap[key])\n                        positionalMap[key] = parsed.argv[key];\n                    argv[key] = parsed.argv[key];\n                }\n            });\n        }\n    }\n    self.cmdToParseOptions = function (cmdString) {\n        const parseOptions = {\n            array: [],\n            default: {},\n            alias: {},\n            demand: {}\n        };\n        const parsed = parse_command_1.parseCommand(cmdString);\n        parsed.demanded.forEach((d) => {\n            const [cmd, ...aliases] = d.cmd;\n            if (d.variadic) {\n                parseOptions.array.push(cmd);\n                parseOptions.default[cmd] = [];\n            }\n            parseOptions.alias[cmd] = aliases;\n            parseOptions.demand[cmd] = true;\n        });\n        parsed.optional.forEach((o) => {\n            const [cmd, ...aliases] = o.cmd;\n            if (o.variadic) {\n                parseOptions.array.push(cmd);\n                parseOptions.default[cmd] = [];\n            }\n            parseOptions.alias[cmd] = aliases;\n        });\n        return parseOptions;\n    };\n    self.reset = () => {\n        handlers = {};\n        aliasMap = {};\n        defaultCommand = undefined;\n        return self;\n    };\n    // used by yargs.parse() to freeze\n    // the state of commands such that\n    // we can apply .parse() multiple times\n    // with the same yargs instance.\n    const frozens = [];\n    self.freeze = () => {\n        frozens.push({\n            handlers,\n            aliasMap,\n            defaultCommand\n        });\n    };\n    self.unfreeze = () => {\n        const frozen = frozens.pop();\n        common_types_1.assertNotStrictEqual(frozen, undefined);\n        ({\n            handlers,\n            aliasMap,\n            defaultCommand\n        } = frozen);\n    };\n    return self;\n}\nexports.command = command;\nfunction isCommandHandlerDefinition(cmd) {\n    return typeof cmd === 'object';\n}\nexports.isCommandHandlerDefinition = isCommandHandlerDefinition;\nfunction isCommandBuilderDefinition(builder) {\n    return typeof builder === 'object' &&\n        !!builder.builder &&\n        typeof builder.handler === 'function';\n}\nexports.isCommandBuilderDefinition = isCommandBuilderDefinition;\nfunction isCommandBuilderCallback(builder) {\n    return typeof builder === 'function';\n}\nexports.isCommandBuilderCallback = isCommandBuilderCallback;\nfunction isCommandBuilderOptionDefinitions(builder) {\n    return typeof builder === 'object';\n}\n"]},"metadata":{},"sourceType":"script"}