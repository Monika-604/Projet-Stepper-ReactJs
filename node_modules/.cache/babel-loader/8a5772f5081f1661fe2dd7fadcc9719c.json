{"ast":null,"code":"'use strict';\n\nconst stringWidth = require('string-width');\n\nconst stripAnsi = require('strip-ansi');\n\nconst wrap = require('wrap-ansi');\n\nconst align = {\n  right: alignRight,\n  center: alignCenter\n};\nconst top = 0;\nconst right = 1;\nconst bottom = 2;\nconst left = 3;\n\nclass UI {\n  constructor(opts) {\n    this.width = opts.width;\n    this.wrap = opts.wrap;\n    this.rows = [];\n  }\n\n  span(...args) {\n    const cols = this.div(...args);\n    cols.span = true;\n  }\n\n  resetOutput() {\n    this.rows = [];\n  }\n\n  div(...args) {\n    if (args.length === 0) {\n      this.div('');\n    }\n\n    if (this.wrap && this._shouldApplyLayoutDSL(...args)) {\n      return this._applyLayoutDSL(args[0]);\n    }\n\n    const cols = args.map(arg => {\n      if (typeof arg === 'string') {\n        return this._colFromString(arg);\n      }\n\n      return arg;\n    });\n    this.rows.push(cols);\n    return cols;\n  }\n\n  _shouldApplyLayoutDSL(...args) {\n    return args.length === 1 && typeof args[0] === 'string' && /[\\t\\n]/.test(args[0]);\n  }\n\n  _applyLayoutDSL(str) {\n    const rows = str.split('\\n').map(row => row.split('\\t'));\n    let leftColumnWidth = 0; // simple heuristic for layout, make sure the\n    // second column lines up along the left-hand.\n    // don't allow the first column to take up more\n    // than 50% of the screen.\n\n    rows.forEach(columns => {\n      if (columns.length > 1 && stringWidth(columns[0]) > leftColumnWidth) {\n        leftColumnWidth = Math.min(Math.floor(this.width * 0.5), stringWidth(columns[0]));\n      }\n    }); // generate a table:\n    //  replacing ' ' with padding calculations.\n    //  using the algorithmically generated width.\n\n    rows.forEach(columns => {\n      this.div(...columns.map((r, i) => {\n        return {\n          text: r.trim(),\n          padding: this._measurePadding(r),\n          width: i === 0 && columns.length > 1 ? leftColumnWidth : undefined\n        };\n      }));\n    });\n    return this.rows[this.rows.length - 1];\n  }\n\n  _colFromString(text) {\n    return {\n      text,\n      padding: this._measurePadding(text)\n    };\n  }\n\n  _measurePadding(str) {\n    // measure padding without ansi escape codes\n    const noAnsi = stripAnsi(str);\n    return [0, noAnsi.match(/\\s*$/)[0].length, 0, noAnsi.match(/^\\s*/)[0].length];\n  }\n\n  toString() {\n    const lines = [];\n    this.rows.forEach(row => {\n      this.rowToString(row, lines);\n    }); // don't display any lines with the\n    // hidden flag set.\n\n    return lines.filter(line => !line.hidden).map(line => line.text).join('\\n');\n  }\n\n  rowToString(row, lines) {\n    this._rasterize(row).forEach((rrow, r) => {\n      let str = '';\n      rrow.forEach((col, c) => {\n        const {\n          width\n        } = row[c]; // the width with padding.\n\n        const wrapWidth = this._negatePadding(row[c]); // the width without padding.\n\n\n        let ts = col; // temporary string used during alignment/padding.\n\n        if (wrapWidth > stringWidth(col)) {\n          ts += ' '.repeat(wrapWidth - stringWidth(col));\n        } // align the string within its column.\n\n\n        if (row[c].align && row[c].align !== 'left' && this.wrap) {\n          ts = align[row[c].align](ts, wrapWidth);\n\n          if (stringWidth(ts) < wrapWidth) {\n            ts += ' '.repeat(width - stringWidth(ts) - 1);\n          }\n        } // apply border and padding to string.\n\n\n        const padding = row[c].padding || [0, 0, 0, 0];\n\n        if (padding[left]) {\n          str += ' '.repeat(padding[left]);\n        }\n\n        str += addBorder(row[c], ts, '| ');\n        str += ts;\n        str += addBorder(row[c], ts, ' |');\n\n        if (padding[right]) {\n          str += ' '.repeat(padding[right]);\n        } // if prior row is span, try to render the\n        // current row on the prior line.\n\n\n        if (r === 0 && lines.length > 0) {\n          str = this._renderInline(str, lines[lines.length - 1]);\n        }\n      }); // remove trailing whitespace.\n\n      lines.push({\n        text: str.replace(/ +$/, ''),\n        span: row.span\n      });\n    });\n\n    return lines;\n  } // if the full 'source' can render in\n  // the target line, do so.\n\n\n  _renderInline(source, previousLine) {\n    const leadingWhitespace = source.match(/^ */)[0].length;\n    const target = previousLine.text;\n    const targetTextWidth = stringWidth(target.trimRight());\n\n    if (!previousLine.span) {\n      return source;\n    } // if we're not applying wrapping logic,\n    // just always append to the span.\n\n\n    if (!this.wrap) {\n      previousLine.hidden = true;\n      return target + source;\n    }\n\n    if (leadingWhitespace < targetTextWidth) {\n      return source;\n    }\n\n    previousLine.hidden = true;\n    return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();\n  }\n\n  _rasterize(row) {\n    const rrows = [];\n\n    const widths = this._columnWidths(row);\n\n    let wrapped; // word wrap all columns, and create\n    // a data-structure that is easy to rasterize.\n\n    row.forEach((col, c) => {\n      // leave room for left and right padding.\n      col.width = widths[c];\n\n      if (this.wrap) {\n        wrapped = wrap(col.text, this._negatePadding(col), {\n          hard: true\n        }).split('\\n');\n      } else {\n        wrapped = col.text.split('\\n');\n      }\n\n      if (col.border) {\n        wrapped.unshift('.' + '-'.repeat(this._negatePadding(col) + 2) + '.');\n        wrapped.push(\"'\" + '-'.repeat(this._negatePadding(col) + 2) + \"'\");\n      } // add top and bottom padding.\n\n\n      if (col.padding) {\n        wrapped.unshift(...new Array(col.padding[top] || 0).fill(''));\n        wrapped.push(...new Array(col.padding[bottom] || 0).fill(''));\n      }\n\n      wrapped.forEach((str, r) => {\n        if (!rrows[r]) {\n          rrows.push([]);\n        }\n\n        const rrow = rrows[r];\n\n        for (let i = 0; i < c; i++) {\n          if (rrow[i] === undefined) {\n            rrow.push('');\n          }\n        }\n\n        rrow.push(str);\n      });\n    });\n    return rrows;\n  }\n\n  _negatePadding(col) {\n    let wrapWidth = col.width;\n\n    if (col.padding) {\n      wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);\n    }\n\n    if (col.border) {\n      wrapWidth -= 4;\n    }\n\n    return wrapWidth;\n  }\n\n  _columnWidths(row) {\n    if (!this.wrap) {\n      return row.map(col => {\n        return col.width || stringWidth(col.text);\n      });\n    }\n\n    let unset = row.length;\n    let remainingWidth = this.width; // column widths can be set in config.\n\n    const widths = row.map(col => {\n      if (col.width) {\n        unset--;\n        remainingWidth -= col.width;\n        return col.width;\n      }\n\n      return undefined;\n    }); // any unset widths should be calculated.\n\n    const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;\n    return widths.map((w, i) => {\n      if (w === undefined) {\n        return Math.max(unsetWidth, _minWidth(row[i]));\n      }\n\n      return w;\n    });\n  }\n\n}\n\nfunction addBorder(col, ts, style) {\n  if (col.border) {\n    if (/[.']-+[.']/.test(ts)) {\n      return '';\n    }\n\n    if (ts.trim().length !== 0) {\n      return style;\n    }\n\n    return '  ';\n  }\n\n  return '';\n} // calculates the minimum width of\n// a column, based on padding preferences.\n\n\nfunction _minWidth(col) {\n  const padding = col.padding || [];\n  const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);\n\n  if (col.border) {\n    return minWidth + 4;\n  }\n\n  return minWidth;\n}\n\nfunction getWindowWidth() {\n  /* istanbul ignore next: depends on terminal */\n  if (typeof process === 'object' && process.stdout && process.stdout.columns) {\n    return process.stdout.columns;\n  }\n}\n\nfunction alignRight(str, width) {\n  str = str.trim();\n  const strWidth = stringWidth(str);\n\n  if (strWidth < width) {\n    return ' '.repeat(width - strWidth) + str;\n  }\n\n  return str;\n}\n\nfunction alignCenter(str, width) {\n  str = str.trim();\n  const strWidth = stringWidth(str);\n  /* istanbul ignore next */\n\n  if (strWidth >= width) {\n    return str;\n  }\n\n  return ' '.repeat(width - strWidth >> 1) + str;\n}\n\nmodule.exports = function (opts = {}) {\n  return new UI({\n    width: opts.width || getWindowWidth() ||\n    /* istanbul ignore next */\n    80,\n    wrap: opts.wrap !== false\n  });\n};","map":{"version":3,"sources":["/Users/monika/Desktop/test/node_modules/cliui/index.js"],"names":["stringWidth","require","stripAnsi","wrap","align","right","alignRight","center","alignCenter","top","bottom","left","UI","constructor","opts","width","rows","span","args","cols","div","resetOutput","length","_shouldApplyLayoutDSL","_applyLayoutDSL","map","arg","_colFromString","push","test","str","split","row","leftColumnWidth","forEach","columns","Math","min","floor","r","i","text","trim","padding","_measurePadding","undefined","noAnsi","match","toString","lines","rowToString","filter","line","hidden","join","_rasterize","rrow","col","c","wrapWidth","_negatePadding","ts","repeat","addBorder","_renderInline","replace","source","previousLine","leadingWhitespace","target","targetTextWidth","trimRight","trimLeft","rrows","widths","_columnWidths","wrapped","hard","border","unshift","Array","fill","unset","remainingWidth","unsetWidth","w","max","_minWidth","style","minWidth","getWindowWidth","process","stdout","strWidth","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst stringWidth = require('string-width')\nconst stripAnsi = require('strip-ansi')\nconst wrap = require('wrap-ansi')\n\nconst align = {\n  right: alignRight,\n  center: alignCenter\n}\nconst top = 0\nconst right = 1\nconst bottom = 2\nconst left = 3\n\nclass UI {\n  constructor (opts) {\n    this.width = opts.width\n    this.wrap = opts.wrap\n    this.rows = []\n  }\n\n  span (...args) {\n    const cols = this.div(...args)\n    cols.span = true\n  }\n\n  resetOutput () {\n    this.rows = []\n  }\n\n  div (...args) {\n    if (args.length === 0) {\n      this.div('')\n    }\n\n    if (this.wrap && this._shouldApplyLayoutDSL(...args)) {\n      return this._applyLayoutDSL(args[0])\n    }\n\n    const cols = args.map(arg => {\n      if (typeof arg === 'string') {\n        return this._colFromString(arg)\n      }\n\n      return arg\n    })\n\n    this.rows.push(cols)\n    return cols\n  }\n\n  _shouldApplyLayoutDSL (...args) {\n    return args.length === 1 && typeof args[0] === 'string' &&\n      /[\\t\\n]/.test(args[0])\n  }\n\n  _applyLayoutDSL (str) {\n    const rows = str.split('\\n').map(row => row.split('\\t'))\n    let leftColumnWidth = 0\n\n    // simple heuristic for layout, make sure the\n    // second column lines up along the left-hand.\n    // don't allow the first column to take up more\n    // than 50% of the screen.\n    rows.forEach(columns => {\n      if (columns.length > 1 && stringWidth(columns[0]) > leftColumnWidth) {\n        leftColumnWidth = Math.min(\n          Math.floor(this.width * 0.5),\n          stringWidth(columns[0])\n        )\n      }\n    })\n\n    // generate a table:\n    //  replacing ' ' with padding calculations.\n    //  using the algorithmically generated width.\n    rows.forEach(columns => {\n      this.div(...columns.map((r, i) => {\n        return {\n          text: r.trim(),\n          padding: this._measurePadding(r),\n          width: (i === 0 && columns.length > 1) ? leftColumnWidth : undefined\n        }\n      }))\n    })\n\n    return this.rows[this.rows.length - 1]\n  }\n\n  _colFromString (text) {\n    return {\n      text,\n      padding: this._measurePadding(text)\n    }\n  }\n\n  _measurePadding (str) {\n    // measure padding without ansi escape codes\n    const noAnsi = stripAnsi(str)\n    return [0, noAnsi.match(/\\s*$/)[0].length, 0, noAnsi.match(/^\\s*/)[0].length]\n  }\n\n  toString () {\n    const lines = []\n\n    this.rows.forEach(row => {\n      this.rowToString(row, lines)\n    })\n\n    // don't display any lines with the\n    // hidden flag set.\n    return lines\n      .filter(line => !line.hidden)\n      .map(line => line.text)\n      .join('\\n')\n  }\n\n  rowToString (row, lines) {\n    this._rasterize(row).forEach((rrow, r) => {\n      let str = ''\n      rrow.forEach((col, c) => {\n        const { width } = row[c] // the width with padding.\n        const wrapWidth = this._negatePadding(row[c]) // the width without padding.\n\n        let ts = col // temporary string used during alignment/padding.\n\n        if (wrapWidth > stringWidth(col)) {\n          ts += ' '.repeat(wrapWidth - stringWidth(col))\n        }\n\n        // align the string within its column.\n        if (row[c].align && row[c].align !== 'left' && this.wrap) {\n          ts = align[row[c].align](ts, wrapWidth)\n          if (stringWidth(ts) < wrapWidth) {\n            ts += ' '.repeat(width - stringWidth(ts) - 1)\n          }\n        }\n\n        // apply border and padding to string.\n        const padding = row[c].padding || [0, 0, 0, 0]\n        if (padding[left]) {\n          str += ' '.repeat(padding[left])\n        }\n\n        str += addBorder(row[c], ts, '| ')\n        str += ts\n        str += addBorder(row[c], ts, ' |')\n        if (padding[right]) {\n          str += ' '.repeat(padding[right])\n        }\n\n        // if prior row is span, try to render the\n        // current row on the prior line.\n        if (r === 0 && lines.length > 0) {\n          str = this._renderInline(str, lines[lines.length - 1])\n        }\n      })\n\n      // remove trailing whitespace.\n      lines.push({\n        text: str.replace(/ +$/, ''),\n        span: row.span\n      })\n    })\n\n    return lines\n  }\n\n  // if the full 'source' can render in\n  // the target line, do so.\n  _renderInline (source, previousLine) {\n    const leadingWhitespace = source.match(/^ */)[0].length\n    const target = previousLine.text\n    const targetTextWidth = stringWidth(target.trimRight())\n\n    if (!previousLine.span) {\n      return source\n    }\n\n    // if we're not applying wrapping logic,\n    // just always append to the span.\n    if (!this.wrap) {\n      previousLine.hidden = true\n      return target + source\n    }\n\n    if (leadingWhitespace < targetTextWidth) {\n      return source\n    }\n\n    previousLine.hidden = true\n\n    return target.trimRight() + ' '.repeat(leadingWhitespace - targetTextWidth) + source.trimLeft()\n  }\n\n  _rasterize (row) {\n    const rrows = []\n    const widths = this._columnWidths(row)\n    let wrapped\n\n    // word wrap all columns, and create\n    // a data-structure that is easy to rasterize.\n    row.forEach((col, c) => {\n      // leave room for left and right padding.\n      col.width = widths[c]\n      if (this.wrap) {\n        wrapped = wrap(col.text, this._negatePadding(col), { hard: true }).split('\\n')\n      } else {\n        wrapped = col.text.split('\\n')\n      }\n\n      if (col.border) {\n        wrapped.unshift('.' + '-'.repeat(this._negatePadding(col) + 2) + '.')\n        wrapped.push(\"'\" + '-'.repeat(this._negatePadding(col) + 2) + \"'\")\n      }\n\n      // add top and bottom padding.\n      if (col.padding) {\n        wrapped.unshift(...new Array(col.padding[top] || 0).fill(''))\n        wrapped.push(...new Array(col.padding[bottom] || 0).fill(''))\n      }\n\n      wrapped.forEach((str, r) => {\n        if (!rrows[r]) {\n          rrows.push([])\n        }\n\n        const rrow = rrows[r]\n\n        for (let i = 0; i < c; i++) {\n          if (rrow[i] === undefined) {\n            rrow.push('')\n          }\n        }\n\n        rrow.push(str)\n      })\n    })\n\n    return rrows\n  }\n\n  _negatePadding (col) {\n    let wrapWidth = col.width\n    if (col.padding) {\n      wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0)\n    }\n\n    if (col.border) {\n      wrapWidth -= 4\n    }\n\n    return wrapWidth\n  }\n\n  _columnWidths (row) {\n    if (!this.wrap) {\n      return row.map(col => {\n        return col.width || stringWidth(col.text)\n      })\n    }\n\n    let unset = row.length\n    let remainingWidth = this.width\n\n    // column widths can be set in config.\n    const widths = row.map(col => {\n      if (col.width) {\n        unset--\n        remainingWidth -= col.width\n        return col.width\n      }\n\n      return undefined\n    })\n\n    // any unset widths should be calculated.\n    const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0\n\n    return widths.map((w, i) => {\n      if (w === undefined) {\n        return Math.max(unsetWidth, _minWidth(row[i]))\n      }\n\n      return w\n    })\n  }\n}\n\nfunction addBorder (col, ts, style) {\n  if (col.border) {\n    if (/[.']-+[.']/.test(ts)) {\n      return ''\n    }\n\n    if (ts.trim().length !== 0) {\n      return style\n    }\n\n    return '  '\n  }\n\n  return ''\n}\n\n// calculates the minimum width of\n// a column, based on padding preferences.\nfunction _minWidth (col) {\n  const padding = col.padding || []\n  const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0)\n  if (col.border) {\n    return minWidth + 4\n  }\n\n  return minWidth\n}\n\nfunction getWindowWidth () {\n  /* istanbul ignore next: depends on terminal */\n  if (typeof process === 'object' && process.stdout && process.stdout.columns) {\n    return process.stdout.columns\n  }\n}\n\nfunction alignRight (str, width) {\n  str = str.trim()\n  const strWidth = stringWidth(str)\n\n  if (strWidth < width) {\n    return ' '.repeat(width - strWidth) + str\n  }\n\n  return str\n}\n\nfunction alignCenter (str, width) {\n  str = str.trim()\n  const strWidth = stringWidth(str)\n\n  /* istanbul ignore next */\n  if (strWidth >= width) {\n    return str\n  }\n\n  return ' '.repeat((width - strWidth) >> 1) + str\n}\n\nmodule.exports = function (opts = {}) {\n  return new UI({\n    width: opts.width || getWindowWidth() || /* istanbul ignore next */ 80,\n    wrap: opts.wrap !== false\n  })\n}\n"]},"metadata":{},"sourceType":"script"}